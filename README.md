# dian_summer_camp
## Expected Behavior
* 
## Current Behavior

### 7/23
1）当天概述
* 上午去启明学院搞清楚了后面需要做些什么。
* 下午补完课后回来熟悉了一下linux中的vim基本操作。（之前太长时间都没使用linux了）
* 回顾了dian Shell 的一些代码，再次理解了需要做什么。
* 写了一点点东西，了解一下怎么用g++编译c++多文件系统

2）具体收获记录

>* vim编辑器中可以用d$删除光标所在位置到行尾的内容
>* d0与之相反。x/X快捷键分别是删除后面一个元素/删除前面一个元素！
>* linux中编译运行c++程序。
>* g++ hello.cpp -o hello   ./hello
>* 或者gcc hello.cpp -lstdc++ -o hello

* git 上传文件的全过程

```cpp
git init
git add
git commit -m ""
git remote add origin git@...
git push -u origin master
```

* gcc编译c与文件全过程

```cpp
1.编译预处理（Processing）
编译器将C程序的头文件编译进来，还有宏的替换
gcc -E hello.c -o hello.i

2.编译（compilation）
将预处理输出文件hello.i汇编成hello.s文件（可编译文件）
gcc -S hello.i -o hello.s

3.汇编（Assemble）
把编译阶段生成的.s 文件转换为二进制目标代码
gcc -c hello.s -o hello.o

4.链接（Linking）
将汇编输出文件hello.s编译输出hello.o文件
gcc hello.o -o hello
```

* 头文件中应该书写的内容

1）通过上面的讨论，我们可以了解到，头文件的作用就是被其他的 .cpp 包含进去的。它们本身并不参与编译，但实际上，它们的内容却在多个 .cpp 文件中得到了编译。通过"定义只能有一次"的规则，我们很容易可以得出，头文件中应该只放变量和函数的声明，而不能放它们的定义。因为一个头文件的内容实际上是会被引入到多个不同的 .cpp 文件中的，并且它们都会被编译。放声明当然没事，如果放了定义，那么也就相当于在多个文件中出现了对于一个符号（变量或函数）的定义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法。

所以，应该记住的一点就是，.h头文件中，只能存在变量或者函数的声明，而不要放定义。即，只能在头文件中写形如：extern int a; 和 void f(); 的句子。这些才是声明。如果写上 inta;或者 void f() {} 这样的句子，那么一旦这个头文件被两个或两个以上的 .cpp 文件包含的话，编译器会立马报错。（关于 extern，前面有讨论过，这里不再讨论定义跟声明的区别了。）

但是，这个规则是有三个例外的:

1. 头文件中可以写 const 对象的定义。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 .cpp 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同时，因为这些 .cpp 文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些 .cpp 文件中的这个 const 对象的值是相同的，可谓一举两得。同理，static 对象的定义也可以放进头文件。
2. 头文件中可以写内联函数（inline）的定义。因为inline函数是需要编译器在遇到它的地方根据它的定义把它内联展开的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法，因此 C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。
3. 头文件中可以写类（class）的定义。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。所以把类的定义放进头文件，在使用到这个类的 .cpp 文件中去包含这个头文件，是一个很好的做法。在这里，值得一提的是，类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。一般，我们的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。这是可以的，也是很好的办法。不过，还有另一种办法。那就是直接把函数成员的实现代码也写进类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。

### 7/24
1）当天概述
* 上午再次复习了一下c++的定义与声明放在.h和.cpp文件中不同位置的问题
* 下午终于发现哪里有问题了。成功用g++和visual studio编译了c++程序
* 晚上学习了git的远程仓库版本管理以及其应用


2）具体收获记录

* 学习运用g++编译c++文件

```cpp
g++ a.cpp --save-temps//保存中间文件
g++ a.cpp --save-temps -Wall//报出所有可能存在的warning
```

```cpp
git log
git log --pretty=oneline
git log --oneline//只显示过去的版本
git reflog//可以显示移动几步回退版本。同时显示过去和未来的所有版本
```

* 版本回退命令

```cpp
使用索引值：git reset --hard [index]
使用^符号：git reset --hard^^^(回退几步)
后退三步或者三步以上，使用~符号：git reset --hard~3
```
* reset 的三个参数对比

```cpp
--soft参数
仅仅在本地库移动HEAD指针

--mixed参数
在本地库移动HEAD指针
重置暂存区

--hard参数
在本地库移动HEAD指针
重置暂存区
重置工作区
```

* git diff的使用

```cpp
1.不加参数表示将工作区和缓存区进行比较
git diff a.txt
2.将文件和本地库中的版本进行比较
git diff HEAD a.txt
3.或者可以和某个历史版本进行比较
git diff HEAD^ a.txt
```
* 远程仓库的命令

```cpp
常用的remote、fetch、push、pull
远程仓库副本的概念。已经理解远程仓库副本与本地/远程仓库的区别

远程仓库副本位于本地，其实一个只读的指针，保存在git的目录里。
```
### 7/25
1）当天概述
* 对自己github里面的远程仓库进行修改（做完刚学过的东西）


2）具体收获记录

```cpp
git fetch [远程库地址别名] [远程分支名]
git merge [远程库地址别名/远程分支名]
git pull [远程库地址别名] [远程分支名]
```

## Possible Solution
## Steps to Reproduce
1.
2.
3.
4.
## Context(Environment)
## Detailed Description
## Possible Implementation


